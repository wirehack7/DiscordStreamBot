name: Release and Tag

on:
  push:
    tags:
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g., v1.0.0)"
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write

    outputs:
      version: ${{ steps.get_version.outputs.version }}
      tag: ${{ steps.get_version.outputs.tag }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version information
        id: get_version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/}
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag=${VERSION}" >> $GITHUB_OUTPUT
          echo "VERSION=${VERSION}" >> $GITHUB_ENV

      - name: Validate version format
        run: |
          if [[ ! "${{ steps.get_version.outputs.version }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Version must be in format v1.2.3"
            exit 1
          fi

      - name: Set up Docker
        run: |
          # Enable Docker buildx
          docker buildx create --use --name builder
          docker buildx inspect --bootstrap

      - name: Log in to Container Registry
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

      - name: Extract metadata for release
        id: meta
        run: |
          # Generate release tags
          VERSION="${{ steps.get_version.outputs.version }}"
          TAGS="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION}"
          TAGS="$TAGS,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          TAGS="$TAGS,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:stable"

          # Extract semantic version parts
          if [[ $VERSION =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            PATCH="${BASH_REMATCH[3]}"

            TAGS="$TAGS,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${MAJOR}.${MINOR}.${PATCH}"
            TAGS="$TAGS,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${MAJOR}.${MINOR}"
            TAGS="$TAGS,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${MAJOR}"
          fi

          # Generate labels
          LABELS="org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          LABELS="$LABELS,org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}"
          LABELS="$LABELS,org.opencontainers.image.version=${VERSION}"
          LABELS="$LABELS,org.opencontainers.image.revision=${{ github.sha }}"
          LABELS="$LABELS,org.opencontainers.image.title=DiscordStreamBot"
          LABELS="$LABELS,org.opencontainers.image.description=Discord bot for streaming notifications"

          echo "tags=$TAGS" >> $GITHUB_OUTPUT
          echo "labels=$LABELS" >> $GITHUB_OUTPUT

      - name: Build and push release Docker image
        run: |
          # Prepare build arguments
          BUILD_ARGS="--build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          BUILD_ARGS="$BUILD_ARGS --build-arg VERSION=${{ steps.get_version.outputs.version }}"

          # Prepare labels
          LABEL_ARGS=""
          IFS=',' read -ra LABEL_ARRAY <<< "${{ steps.meta.outputs.labels }}"
          for label in "${LABEL_ARRAY[@]}"; do
            LABEL_ARGS="$LABEL_ARGS --label $label"
          done

          # Prepare tags
          TAG_ARGS=""
          IFS=',' read -ra TAG_ARRAY <<< "${{ steps.meta.outputs.tags }}"
          for tag in "${TAG_ARRAY[@]}"; do
            TAG_ARGS="$TAG_ARGS -t $tag"
          done

          # Build and push for multiple platforms
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --push \
            $BUILD_ARGS \
            $LABEL_ARGS \
            $TAG_ARGS \
            -f ./Dockerfile \
            .

      - name: Generate changelog
        id: changelog
        run: |
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" ${LAST_TAG}..HEAD)
          else
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --max-count=10)
          fi

          # Create changelog content
          CHANGELOG_CONTENT="## üöÄ What's New

          $CHANGELOG

          ## üê≥ Docker Images

          - **Latest**: \`ghcr.io/${{ github.repository }}:latest\`
          - **This version**: \`ghcr.io/${{ github.repository }}:${{ steps.get_version.outputs.version }}\`
          - **Stable**: \`ghcr.io/${{ github.repository }}:stable\`

          ## üì¶ Installation

          ### Docker (Recommended)
          \`\`\`bash
          # Pull specific version
          docker pull ghcr.io/${{ github.repository }}:${{ steps.get_version.outputs.version }}

          # Or pull latest
          docker pull ghcr.io/${{ github.repository }}:latest

          # Run with docker-compose
          cd deploy
          docker-compose up -d
          \`\`\`

          ### Local Installation
          \`\`\`bash
          # Clone this version
          git clone --branch ${{ steps.get_version.outputs.version }} https://github.com/${{ github.repository }}.git
          cd DiscordStreamBot

          # Setup and run
          python scripts/setup.py install
          cp config/config.ini.dist config.ini
          # Edit config.ini with your credentials
          python src/main.py
          \`\`\`

          ## üîß Configuration

          Make sure to update your \`config.ini\` with the latest template from \`config/config.ini.dist\`.

          ## üìö Documentation

          - [README](README.md) - Setup and usage guide
          - [Docker Usage](README.md#docker) - Docker deployment instructions

          ---

          **Full Changelog**: https://github.com/${{ github.repository }}/compare/\${LAST_TAG}...${{ steps.get_version.outputs.version }}"

          # Save changelog to file and output
          echo "$CHANGELOG_CONTENT" > CHANGELOG.tmp

          # Set multiline output
          {
            echo "changelog<<CHANGELOG_EOF"
            echo "$CHANGELOG_CONTENT"
            echo "CHANGELOG_EOF"
          } >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create release using GitHub CLI
          gh release create "${{ steps.get_version.outputs.tag }}" \
            --title "Release ${{ steps.get_version.outputs.version }}" \
            --notes "${{ steps.changelog.outputs.changelog }}" \
            --generate-notes \
            --repo "${{ github.repository }}"

      - name: Security scan release image
        run: |
          # Pull the built image for scanning
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.get_version.outputs.version }}

          # Basic security scan using native Docker commands
          echo "## üîç Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check image history
          echo "### Image History" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          docker history ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.get_version.outputs.version }} --no-trunc >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

          # Basic image inspection
          echo "### Image Configuration" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          docker inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.get_version.outputs.version }} --format='User: {{.Config.User}}' >> $GITHUB_STEP_SUMMARY || echo "User: root"
          docker inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.get_version.outputs.version }} --format='WorkingDir: {{.Config.WorkingDir}}' >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

          # List installed packages
          echo "### Installed Python Packages" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.get_version.outputs.version }} pip list >> $GITHUB_STEP_SUMMARY || echo "Could not list packages"
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

          # Create basic SARIF file
          cat > trivy-results.sarif << EOF
          {
            "version": "2.1.0",
            "\$schema": "https://json.schemastore.org/sarif-2.1.0.json",
            "runs": [
              {
                "tool": {
                  "driver": {
                    "name": "docker-native-scan",
                    "version": "1.0.0"
                  }
                },
                "results": []
              }
            ]
          }
          EOF

      - name: Upload security scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: "trivy-results.sarif"
        continue-on-error: true

      - name: Update Docker Compose files with new version
        run: |
          # Update production docker-compose with new version
          sed -i "s|ghcr.io/.*/discordstreambot:.*|ghcr.io/${{ github.repository }}:${{ steps.get_version.outputs.version }}|g" docker-compose.yml

          # Create a commit with updated files (optional)
          if git diff --quiet; then
            echo "No changes to commit"
          else
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git add docker-compose.yml
            git commit -m "Update Docker Compose files to ${{ steps.get_version.outputs.version }}" || exit 0
            git push origin HEAD:main || exit 0
          fi

      - name: Generate deployment summary
        run: |
          echo "## üéâ Release ${{ steps.get_version.outputs.version }} Published" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The release has been successfully created and Docker images have been published." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Docker Images" >> $GITHUB_STEP_SUMMARY
          echo "- \`ghcr.io/${{ github.repository }}:${{ steps.get_version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`ghcr.io/${{ github.repository }}:latest\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`ghcr.io/${{ github.repository }}:stable\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üöÄ Quick Deployment" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "docker pull ghcr.io/${{ github.repository }}:${{ steps.get_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Links" >> $GITHUB_STEP_SUMMARY
          echo "- [Release Notes](https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.version }})" >> $GITHUB_STEP_SUMMARY
          echo "- [Docker Images](https://github.com/${{ github.repository }}/pkgs/container/discordstreambot)" >> $GITHUB_STEP_SUMMARY
          echo "- [Documentation](https://github.com/${{ github.repository }}/tree/${{ steps.get_version.outputs.version }}/docs)" >> $GITHUB_STEP_SUMMARY

  notify-success:
    runs-on: ubuntu-latest
    needs: create-release
    if: success()

    steps:
      - name: Success notification
        run: |
          echo "‚úÖ Release ${{ needs.create-release.outputs.version }} completed successfully!"
          echo "Docker images are available at ghcr.io/${{ github.repository }}"

  notify-failure:
    runs-on: ubuntu-latest
    needs: create-release
    if: failure()

    steps:
      - name: Failure notification
        run: |
          echo "‚ùå Release process failed!"
          echo "Please check the workflow logs for details."
          exit 1
